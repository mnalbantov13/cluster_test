<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <title>Cluster Map</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
        #map { height: 950px; width: 100%; }
    </style>
</head>
<body>

<div id="map"></div>

<script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>

<script type="module">
    import DBSCAN from 'https://cdn.skypack.dev/density-clustering';
    const dbscan = new DBSCAN.DBSCAN();;

    const targetClusterId = 11906061 ;

    const csvFileName = 'export_bojurishte_test_clusters_road_signs_records_202507161125.csv';
    const groundCoords = 'export_task_3_signs_google_streetview_check_202507301237.csv';

    const map = L.map('map').setView([41.10264217370007, 1.1165145321662422], 7);

    L.tileLayer('https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}', {
        attribution: 'Tiles Â© Esri | Source: Esri, Maxar, Earthstar Geographics, and the GIS User Community'
    }).addTo(map);
    const groundTruthMap = {};
    // Load ground truth coordinates
    fetch(groundCoords)
        .then(res => {
            if (!res.ok) throw new Error(`Failed to fetch file: ${res.status}`);
            return res.text();
        })
        .then(text => {
            const rows = text.trim().split('\n').map(row => row.split(','));
            const headers = rows[0].map(h => h.trim().replaceAll('"', ''));
            const latIdx = headers.indexOf('lat');
            const lonIdx = headers.indexOf('lon');
            const idIdx = headers.indexOf('road_sign_record_id');

            rows.slice(1).forEach(row => {
                // Clean up values
                const latStr = row[latIdx]?.replaceAll('"', '').trim();
                const lonStr = row[lonIdx]?.replaceAll('"', '').trim();
                const idStr = row[idIdx]?.replaceAll('"', '').trim();

                const lat = parseFloat(latStr);
                const lon = parseFloat(lonStr);
                const id = Number(idStr);

                // Only add valid entries
                if (!isNaN(lat) && !isNaN(lon) && !isNaN(id)) {
                    groundTruthMap[id] = { lat, lon };
                }
            });
        });

    const clustersById = {};
    fetch(csvFileName)
        .then(res => {
            if (!res.ok) throw new Error(`Failed to fetch file: ${res.status}`);
            return res.text();
        })
        .then(text => {
            const rows = text.trim().split('\n').map(row => row.split(','));

            const headers = rows[0].map(h => h.trim().replaceAll('"', ''));
            const Idx = headers.indexOf('id');
            const clusterIdx = headers.indexOf('cluster_id_2');
            const wayLatIdx = headers.indexOf('way_lat');
            const wayLonIdx = headers.indexOf('way_lon');
            const labelIdx = headers.indexOf('recognized_as');
            const imgIdx = headers.indexOf('image_path');
            const headIdx = headers.indexOf('heading')
            const wayDirIdx = headers.indexOf('way_dir')
            //----Target Cluster Logic----
            // const points = [];
            // const pointCoord = [];

            // for (let i = 1; i <rows.length; i++) {
                
            //     const row = rows[i];
            //     const clusterId = row[clusterIdx];
            //     if (parseInt(clusterId) !== targetClusterId) continue;
                
            //     const wayLat = parseFloat(row[wayLatIdx].replaceAll('"', '').trim());
            //     const wayLon = parseFloat(row[wayLonIdx].replaceAll('"', '').trim());
            //     const label = row[labelIdx];
            //     const img = row[imgIdx];
            //     const heading = row[headIdx]
            //     const wayDir = row[wayDirIdx]
            //     const id = row[Idx];

            //     pointCoord.push([wayLat,wayLon])
            //     points.push({
            //         id: id,
            //         lat: wayLat,
            //         lon: wayLon,
            //         heading: heading,
            //         wayDir: wayDir,
            //         img: img,
            //         label: label
            // });
            // }

        //---Group by clusterId---
         // clusterId -> array of point objects

        for (let i = 1; i < rows.length; i++) {
            const row = rows[i];
            const clusterId = parseInt(row[clusterIdx]);

            const wayLat = parseFloat(row[wayLatIdx].replaceAll('"', '').trim());
            const wayLon = parseFloat(row[wayLonIdx].replaceAll('"', '').trim());
            const label = row[labelIdx];
            const img = row[imgIdx];
            const heading = row[headIdx];
            const wayDir = row[wayDirIdx];
            const id = row[Idx];

            const point = {
                id: id,
                lat: wayLat,
                lon: wayLon,
                heading: heading,
                wayDir: wayDir,
                img: img,
                label: label
            };

            if (!clustersById[clusterId]) {
                clustersById[clusterId] = [];
            }

            clustersById[clusterId].push(point);
        
            }

            //Median
            function getMedianPoint(points) {
                const lats = points.map(p => p.lat).sort((a, b) => a - b);
                const lons = points.map(p => p.lon).sort((a, b) => a - b);
                const mid = Math.floor(points.length / 2);
                return {
                    lat: lats[mid], 
                    lon: lons[mid]
                }
            }

            //Centroid
            function getCentroid(points){
                if (points.length === 0) return null;
                let latSum = 0;
                let lonSum = 0;

                points.forEach(p=>{
                    latSum+=p.lat;
                    lonSum+=p.lon;
                })

                const centroidLat = latSum / points.length;
                const centroidLon = lonSum / points.length;

                return {
                    lat: centroidLat,
                    lon: centroidLon
                }
            }

            //Last seen 
            function lastSeen(points, headingDegrees) {
                if (points.length === 0) return null;

                const headingRad = headingDegrees * Math.PI / 180;
                const dirX = Math.sin(headingRad);
                const dirY = Math.cos(headingRad);

                const base = getCentroid(points);
                let lastSeen = points[0];
                let minProjection = -Infinity;

                points.forEach(p => {
                    const dLat = (p.lat - base.lat) * 111320; // meters per degree latitude
                    const dLon = (p.lon - base.lon) * (40075000 / 360) * Math.cos(base.lat * Math.PI / 180);

                    const projection = dLat * dirY + dLon * dirX;

                    if (projection > minProjection) {
                        minProjection = projection;
                        lastSeen = p;
                    }
                });

                return lastSeen;
            }

            //Subclusters
            // const clusters = dbscan.run(points, 0.00015, 3); // 0.001 ~100m
            // const colors = ['red', 'blue', 'green', 'orange', 'purple'];

        
        //Computing Error
        function haversineDistance(coord1, coord2) {
            const R = 6371000; // Earth radius in meters
            const toRad = deg => deg * Math.PI / 180;

            const dLat = toRad(coord2.lat - coord1.lat);
            const dLon = toRad(coord2.lon - coord1.lon);

            const lat1 = toRad(coord1.lat);
            const lat2 = toRad(coord2.lat);

            const a = Math.sin(dLat / 2) ** 2 +
                    Math.cos(lat1) * Math.cos(lat2) * Math.sin(dLon / 2) ** 2;
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

            return R * c;
        }

        // Ground truth map for error calculation

let sumMed = 0, sumCent = 0, sumLast = 0, sumWeighted = 0, count = 0;
let lastSeenOver15 = 0, weightedOver15 = 0;

Object.entries(clustersById).forEach(([clusterId, points]) => {
    clusterId = parseInt(clusterId);
    const groundTruth = groundTruthMap[clusterId];
    if (!groundTruth) return; // Skip clusters with no known truth

    // Compute estimates
    const median = getMedianPoint(points);
    const centroid = getCentroid(points);
    const last = lastSeen(points, points[0].wayDir);

    const dMed = haversineDistance(groundTruth, median);
    const dCent = haversineDistance(groundTruth, centroid);
    const dLast = haversineDistance(groundTruth, last);

    const d = haversineDistance(last, median);
    const w = Math.min(1, 20 / d); // Blend weight

    // Compute blended coordinates
    const blended = {
        lat: w * last.lat + (1 - w) * median.lat,
        lon: w * last.lon + (1 - w) * median.lon
    };

    // Find the cluster point closest to the blended coordinates
    let minDist = Infinity;
    let weighted = points[0];
    points.forEach(p => {
        const dist = haversineDistance(blended, { lat: p.lat, lon: p.lon });
        if (dist < minDist) {
            minDist = dist;
            weighted = p;
        }
    });
    const dWeighted = haversineDistance(groundTruth, weighted);

    sumMed += dMed;
    sumCent += dCent;
    sumLast += dLast;
    sumWeighted += dWeighted;
    count++;

    // Only count clusters with more than 1 point for over-15m stats
    if (points.length > 0) {
        if (dLast > 15) lastSeenOver15++;
        if (dWeighted > 15) weightedOver15++;
    }

    console.log(`Cluster ${clusterId} Errors:`);
    console.log(`- Median: ${dMed.toFixed(1)}m`);
    console.log(`- Centroid: ${dCent.toFixed(1)}m`);
    console.log(`- Last Seen: ${dLast.toFixed(1)}m`);
    console.log(`- Weighted: ${dWeighted.toFixed(1)}m`);
});

if (count > 0) {
    console.log('--- Average Errors ---');
    console.log(`Median: ${(sumMed / count).toFixed(1)}m`);
    console.log(`Centroid: ${(sumCent / count).toFixed(1)}m`);
    console.log(`Last Seen: ${(sumLast / count).toFixed(1)}m`);
    console.log(`Weighted: ${(sumWeighted / count).toFixed(1)}m`);
    console.log(`Number of Last Seen errors > 15m: ${lastSeenOver15}`);
    console.log(`Number of Weighted errors > 15m: ${weightedOver15}`);
} 
 
 // Visualize for a specific cluster
const targetPoints = clustersById[targetClusterId];
if (targetPoints && targetPoints.length > 0) {
    const median = getMedianPoint(targetPoints);
    const centroid = getCentroid(targetPoints);
    const last = lastSeen(targetPoints, targetPoints[0].wayDir);

    // Weighted calculation (same as in your error loop)
    const d = haversineDistance(last, median);
    const w = Math.min(1, 20 / (d || 1));
    const blended = {
        lat: w * last.lat + (1 - w) * median.lat,
        lon: w * last.lon + (1 - w) * median.lon
    };
    // Find closest cluster point to blended
    let minDist = Infinity;
    let weighted = targetPoints[0];
    targetPoints.forEach(p => {
        const dist = haversineDistance(blended, { lat: p.lat, lon: p.lon });
        if (dist < minDist) {
            minDist = dist;
            weighted = p;
        }
    });

    // Plot all cluster points
    targetPoints.forEach(p => {
        L.circleMarker([p.lat, p.lon], {
            radius: 6,
            color: 'red',
            fillOpacity: 0.2,
            weight: 0.5
        }).addTo(map).bindPopup(`Cluster Point<br>ID: ${p.id}<br>${p.lat}, ${p.lon}`);
    });

    // Plot median
    L.circleMarker([median.lat, median.lon], {
        radius: 8,
        color: '#FFFF00',
        fillOpacity: 1
    }).addTo(map).bindPopup(`Median<br>${median.lat.toFixed(6)}, ${median.lon.toFixed(6)}`);

    // Plot centroid
    L.circleMarker([centroid.lat, centroid.lon], {
        radius: 6,
        color: '#008000',
        fillOpacity: 1
    }).addTo(map).bindPopup(`Centroid<br>${centroid.lat.toFixed(6)}, ${centroid.lon.toFixed(6)}`);

    // Plot last seen
    L.circleMarker([last.lat, last.lon], {
        radius: 8,
        color: '#0000FF',
        fillOpacity: 1
    }).addTo(map).bindPopup(`Last Seen<br>${last.lat.toFixed(6)}, ${last.lon.toFixed(6)}`);

    // Plot weighted
    L.circleMarker([weighted.lat, weighted.lon], {
        radius: 4,
        color: '#FF00FF',
        fillOpacity: 0.7
    }).addTo(map).bindPopup(`Weighted<br>${weighted.lat.toFixed(6)}, ${weighted.lon.toFixed(6)}`);
}
});



</script>

</body>
</html>
